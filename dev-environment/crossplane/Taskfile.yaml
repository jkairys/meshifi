version: "3"

vars:
  CROSSPLANE_VERSION: v2.0.2
  GCP_SECRET_NAME: "crossplane-gcp-key"

tasks:
  # Crossplane Installation
  install:
    desc: "Install Crossplane on the Kind cluster"
    silent: true
    cmds:
      - |
        echo "üöÄ Checking Crossplane installation..."

        # Check if Crossplane is already installed
        if helm list -n crossplane-system | grep -q crossplane; then
          echo "‚úÖ Crossplane is already installed"
        else
          echo "üîß Installing Crossplane..."
          helm repo add crossplane-stable https://charts.crossplane.io/stable
          helm repo update
          helm install crossplane crossplane-stable/crossplane \
            --namespace crossplane-system \
            --create-namespace \
            --version {{.CROSSPLANE_VERSION}}
        fi

        echo "‚è≥ Waiting for Crossplane to be ready..."
        kubectl wait --for=condition=Available --timeout=300s deployment/crossplane -n crossplane-system
        echo "‚úÖ Crossplane is ready"
    summary: "Install Crossplane using Helm if not already installed"

  uninstall:
    desc: "Uninstall Crossplane from the cluster"
    silent: true
    cmds:
      - |
        echo "üóëÔ∏è  Uninstalling Crossplane..."

        # Check if cluster exists and is accessible
        if ! kubectl cluster-info &> /dev/null; then
          echo "‚ÑπÔ∏è  No accessible Kubernetes cluster found. Skipping Crossplane uninstall."
          exit 0
        fi

        # Check if Crossplane is installed
        if ! helm list -n crossplane-system | grep -q crossplane; then
          echo "‚ÑπÔ∏è  Crossplane is not installed. Skipping uninstall."
        else
          helm uninstall crossplane -n crossplane-system
        fi

        # Try to delete namespace if it exists
        if kubectl get namespace crossplane-system &> /dev/null; then
          kubectl delete namespace crossplane-system
        else
          echo "‚ÑπÔ∏è  crossplane-system namespace does not exist."
        fi
      - task: clean-crds
      - echo "‚úÖ Crossplane uninstall completed"

  clean-crds:
    desc: "Clean up problematic Crossplane CRDs that may cause version conflicts"
    silent: true
    cmds:
      - |
        echo "üßπ Cleaning up problematic Crossplane CRDs..."

        # Check if cluster exists and is accessible
        if ! kubectl cluster-info &> /dev/null; then
          echo "‚ÑπÔ∏è  No accessible Kubernetes cluster found. Skipping CRD cleanup."
          exit 0
        fi

        # Remove problematic CRDs that might have version conflicts
        echo "üóëÔ∏è  Removing environmentconfigs CRD..."
        kubectl delete crd environmentconfigs.apiextensions.crossplane.io --ignore-not-found=true

        # Remove other Crossplane CRDs that might cause conflicts
        echo "üóëÔ∏è  Removing other Crossplane CRDs..."
        kubectl delete crd compositeresourcedefinitions.apiextensions.crossplane.io --ignore-not-found=true
        kubectl delete crd compositionrevisions.apiextensions.crossplane.io --ignore-not-found=true
        kubectl delete crd compositions.apiextensions.crossplane.io --ignore-not-found=true
        kubectl delete crd configurationrevisions.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd configurations.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd controllerconfigs.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd deploymentruntimeconfigs.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd functionrevisions.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd functions.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd locks.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd providerrevisions.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd providers.pkg.crossplane.io --ignore-not-found=true
        kubectl delete crd storeconfigs.secrets.crossplane.io --ignore-not-found=true
        kubectl delete crd usages.apiextensions.crossplane.io --ignore-not-found=true

        echo "‚úÖ CRD cleanup completed"

  status:
    desc: "Check Crossplane status"
    silent: true
    cmds:
      - kubectl get pods -n crossplane-system
      - kubectl get crd | grep crossplane

  # Crossplane Dependencies
  install-dependencies:
    desc: "Install required Crossplane dependencies"
    silent: true
    deps: [install]
    cmds:
      - |
        echo "üì¶ Checking Crossplane dependencies..."

        # Note: function-go-templating is not available in the registry
        # We'll use basic compositions without functions for now
        echo "‚ÑπÔ∏è  Skipping function-go-templating (not available in registry)"

        # Check if provider-kubernetes is already installed
        if kubectl get provider.pkg.crossplane.io/provider-kubernetes &> /dev/null; then
          echo "‚úÖ provider-kubernetes is already installed"
        else
          echo "üîß Installing provider-kubernetes..."
          echo "apiVersion: pkg.crossplane.io/v1" > /tmp/provider-kubernetes.yaml
          echo "kind: Provider" >> /tmp/provider-kubernetes.yaml
          echo "metadata:" >> /tmp/provider-kubernetes.yaml
          echo "  name: provider-kubernetes" >> /tmp/provider-kubernetes.yaml
          echo "spec:" >> /tmp/provider-kubernetes.yaml
          echo "  package: xpkg.upbound.io/crossplane-contrib/provider-kubernetes:v0.9.0" >> /tmp/provider-kubernetes.yaml
          kubectl apply -f /tmp/provider-kubernetes.yaml
          rm -f /tmp/provider-kubernetes.yaml
        fi

        echo "‚è≥ Waiting for dependencies to be ready..."
        kubectl wait --for=condition=Healthy --timeout=300s provider.pkg.crossplane.io/provider-kubernetes

        echo "‚úÖ Dependencies are ready"
    summary: "Install required Crossplane functions and providers if not already installed"

  # GCP Provider Setup
  uninstall-gcp-provider:
    desc: "Uninstall existing GCP provider from the cluster"
    silent: true
    cmds:
      - |
        echo "üóëÔ∏è  Uninstalling existing GCP provider..."

        # Check if cluster exists and is accessible
        if ! kubectl cluster-info &> /dev/null; then
          echo "‚ÑπÔ∏è  No accessible Kubernetes cluster found. Skipping GCP provider uninstall."
          exit 0
        fi

        # Check if old provider-gcp is installed
        if kubectl get provider.pkg.crossplane.io/provider-gcp &> /dev/null; then
          echo "üîß Uninstalling existing provider-gcp..."
          kubectl delete provider.pkg.crossplane.io/provider-gcp --ignore-not-found=true
          
          # Wait for provider to be removed
          echo "‚è≥ Waiting for provider to be removed..."
          kubectl wait --for=delete provider.pkg.crossplane.io/provider-gcp --timeout=60s || true
          
          echo "‚úÖ Existing provider-gcp uninstalled"
        fi

        # Check if new upbound-provider-gcp-iam is installed
        if kubectl get provider.pkg.crossplane.io/upbound-provider-gcp-iam &> /dev/null; then
          echo "üîß Uninstalling existing upbound-provider-gcp-iam..."
          kubectl delete provider.pkg.crossplane.io/upbound-provider-gcp-iam --ignore-not-found=true
          
          # Wait for provider to be removed
          echo "‚è≥ Waiting for provider to be removed..."
          kubectl wait --for=delete provider.pkg.crossplane.io/upbound-provider-gcp-iam --timeout=60s || true
          
          echo "‚úÖ Existing upbound-provider-gcp-iam uninstalled"
        fi

        # Also check for the family provider
        if kubectl get provider.pkg.crossplane.io/upbound-provider-family-gcp &> /dev/null; then
          echo "üîß Uninstalling existing upbound-provider-family-gcp..."
          kubectl delete provider.pkg.crossplane.io/upbound-provider-family-gcp --ignore-not-found=true
          
          # Wait for provider to be removed
          echo "‚è≥ Waiting for provider to be removed..."
          kubectl wait --for=delete provider.pkg.crossplane.io/upbound-provider-family-gcp --timeout=60s || true
          
          echo "‚úÖ Existing upbound-provider-family-gcp uninstalled"
        fi

        # Clean up any existing GCP ProviderConfigs that might cause conflicts
        echo "üßπ Cleaning up existing GCP ProviderConfigs..."
        kubectl delete providerconfig.gcp.m.upbound.io --all --ignore-not-found=true || true
        kubectl delete providerconfig.gcp.upbound.io --all --ignore-not-found=true || true
        kubectl delete providerconfig.gcp.crossplane.io --all --ignore-not-found=true || true

        # Check if any GCP provider is installed
        if ! kubectl get provider.pkg.crossplane.io/provider-gcp &> /dev/null && ! kubectl get provider.pkg.crossplane.io/upbound-provider-gcp-iam &> /dev/null && ! kubectl get provider.pkg.crossplane.io/upbound-provider-family-gcp &> /dev/null; then
          echo "‚ÑπÔ∏è  No existing GCP provider found to uninstall"
        fi
    summary: "Uninstall existing GCP provider from the cluster"

  install-gcp-providers:
    desc: "Install upjet GCP provider for Crossplane from Upbound registry"
    silent: true
    deps: [install, uninstall-gcp-provider]
    cmds:
      - |
        echo "üîß Installing upjet GCP provider from Upbound registry..."
        kubectl apply -f gcp/providers

        echo "‚è≥ Waiting for GCP IAM provider to be ready..."
        kubectl wait --for=condition=Healthy --timeout=300s provider.pkg.crossplane.io/upbound-provider-gcp-iam

        echo "‚è≥ Waiting for provider config resource CRD to be available..."
        kubectl wait --for=condition=Established --timeout=300s crd/providerconfigs.gcp.m.upbound.io

        kubectl apply -f gcp/provider-config.yaml

        echo "üîç Checking provider config status..."
        kubectl get providerconfig.gcp.m.upbound.io/default -o yaml

        echo "üîç Checking provider events..."
        kubectl get events --field-selector involvedObject.name=upbound-provider-gcp-iam --sort-by='.lastTimestamp'

        echo "‚è≥ Checking if GCP provider config is ready..."
        # Note: upjet providers may not set Healthy condition on ProviderConfig
        # Just verify the ProviderConfig exists and provider is running
        kubectl get providerconfig.gcp.m.upbound.io/default
        kubectl get pods -n crossplane-system | grep gcp

        echo "‚úÖ upjet GCP provider is ready"
    summary: "Install upjet GCP provider for Crossplane from Upbound registry"

  create-gcp-key:
    desc: "Create GCP service account key and store it in GCP Secret Manager"
    silent: true
    requires:
      vars: [GCP_PROJECT_ID]
    vars:
      CROSSPLANE_SERVICE_ACCOUNT_NAME: crossplane
      CROSSPLANE_SERVICE_ACCOUNT_EMAIL: "{{.CROSSPLANE_SERVICE_ACCOUNT_NAME}}@{{.GCP_PROJECT_ID}}.iam.gserviceaccount.com"
      TEMP_KEY_FILE: "/tmp/crossplane-gcp-key.json"

    cmds:
      - |
        echo "üîë Creating GCP service account key and storing in Secret Manager..."

        # Check if GCP_PROJECT_ID is set
        if [ -z "$GCP_PROJECT_ID" ]; then
          echo "‚ùå Error: GCP_PROJECT_ID environment variable is not set"
          echo "Please set it with: export GCP_PROJECT_ID=your-project-id"
          exit 1
        fi

        # Check if gcloud is installed and authenticated
        if ! command -v gcloud &> /dev/null; then
          echo "‚ùå Error: gcloud CLI is not installed"
          echo "Please install it from: https://cloud.google.com/sdk/docs/install"
          exit 1
        fi

        # Check if user is authenticated
        if ! gcloud auth list --filter=status:ACTIVE --format="value(account)" | grep -q .; then
          echo "‚ùå Error: No active gcloud authentication found"
          echo "Please run: gcloud auth login"
          exit 1
        fi

        # Set the project
        echo "üîß Setting GCP project to $GCP_PROJECT_ID..."
        gcloud config set project $GCP_PROJECT_ID

        # Enable Secret Manager API if not already enabled
        echo "üîß Ensuring Secret Manager API is enabled..."
        gcloud services enable secretmanager.googleapis.com

        # Debug: Show variables
        echo "üîç Debug - GCP_PROJECT_ID: $GCP_PROJECT_ID"
        echo "üîç Debug - CROSSPLANE_SERVICE_ACCOUNT_NAME: {{.CROSSPLANE_SERVICE_ACCOUNT_NAME}}"
        echo "üîç Debug - CROSSPLANE_SERVICE_ACCOUNT_EMAIL: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        echo "üîç Debug - GCP_SECRET_NAME: {{.GCP_SECRET_NAME}}"

        # Validate that the service account email was constructed properly
        if [ -z "{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" ]; then
          echo "‚ùå Error: Service account email is empty. Check GCP_PROJECT_ID variable."
          exit 1
        fi

        # Check if service account exists by listing and filtering
        echo "üîç Checking if service account exists: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        if gcloud iam service-accounts list --filter="email:{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" --format="value(email)" | grep -q "^{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}$"; then
          echo "‚úÖ Service account already exists: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        else
          echo "üîß Creating service account: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
          gcloud iam service-accounts create {{.CROSSPLANE_SERVICE_ACCOUNT_NAME}} \
            --display-name="Crossplane" \
            --description="Service account for Crossplane GCP provider"
          
          # Grant Project IAM Admin role to the newly created service account
          echo "üîê Granting Project IAM Admin role to newly created service account..."
          gcloud projects add-iam-policy-binding $GCP_PROJECT_ID \
            --member="serviceAccount:{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" \
            --role="roles/resourcemanager.projectIamAdmin"
        fi

        # Assign only projectIamAdmin, we'll assign the rest using Crossplane
        echo "üîê Assigning required roles to service account..."
        ROLES=(
          "roles/resourcemanager.projectIamAdmin"
        )

        for role in "${ROLES[@]}"; do
          echo "  - Assigning role: $role"
          if ! gcloud projects add-iam-policy-binding $GCP_PROJECT_ID \
            --member="serviceAccount:{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" \
            --role="$role" \
            --quiet; then
            echo "‚ùå Error: Failed to assign role $role to service account"
            echo "This may be due to insufficient permissions or the role already being assigned"
            echo "Continuing with remaining roles..."
          else
            echo "    ‚úÖ Role assigned successfully"
          fi
        done

        # Enable Cloud Resource Manager API
        echo "üîß Enabling Cloud Resource Manager API..."
        gcloud services enable cloudresourcemanager.googleapis.com --project={{.GCP_PROJECT_ID}}

        # Check if service account already has keys in GCP
        echo "üîç Checking if service account has existing keys in GCP..."
        EXISTING_KEYS=$(gcloud iam service-accounts keys list \
          --iam-account={{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}} \
          --format="value(name)" 2>/dev/null | wc -l)

        if [ "$EXISTING_KEYS" -gt 0 ]; then
          echo "‚úÖ Found $EXISTING_KEYS existing key(s) in GCP"
          echo "‚ÑπÔ∏è  Note: GCP doesn't allow downloading existing keys for security reasons"
          echo "üîë Creating a new service account key (existing keys will remain valid)..."
        else
          echo "üîë No existing keys found in GCP, creating new service account key..."
        fi

        # Create a new service account key
        if ! gcloud iam service-accounts keys create {{.TEMP_KEY_FILE}} \
          --iam-account={{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}; then
          echo "‚ùå Error: Failed to create service account key"
          exit 1
        fi

        # Verify key file was created
        if [ ! -f "{{.TEMP_KEY_FILE}}" ]; then
          echo "‚ùå Error: Service account key file was not created"
          exit 1
        fi

        # Check if secret already exists in GCP Secret Manager
        echo "üîç Checking if secret already exists in GCP Secret Manager..."
        if gcloud secrets describe {{.GCP_SECRET_NAME}} --project=$GCP_PROJECT_ID &> /dev/null; then
          echo "‚úÖ Secret {{.GCP_SECRET_NAME}} already exists in GCP Secret Manager"
          echo "üîÑ Updating existing secret with new key..."
          
          # Update the existing secret
          if ! gcloud secrets versions add {{.GCP_SECRET_NAME}} \
            --data-file="{{.TEMP_KEY_FILE}}" \
            --project=$GCP_PROJECT_ID; then
            echo "‚ùå Error: Failed to update existing secret"
            exit 1
          fi
        else
          echo "üîë Creating new secret in GCP Secret Manager..."
          
          # Create the secret
          if ! gcloud secrets create {{.GCP_SECRET_NAME}} \
            --replication-policy="automatic" \
            --project=$GCP_PROJECT_ID; then
            echo "‚ùå Error: Failed to create secret"
            exit 1
          fi
          
          # Add the first version
          if ! gcloud secrets versions add {{.GCP_SECRET_NAME}} \
            --data-file="{{.TEMP_KEY_FILE}}" \
            --project=$GCP_PROJECT_ID; then
            echo "‚ùå Error: Failed to add secret version"
            exit 1
          fi
        fi

        # Grant the service account access to read the secret
        echo "üîê Granting service account access to read the secret..."
        if ! gcloud secrets add-iam-policy-binding {{.GCP_SECRET_NAME}} \
          --member="serviceAccount:{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" \
          --role="roles/secretmanager.secretAccessor" \
          --project=$GCP_PROJECT_ID; then
          echo "‚ùå Error: Failed to grant secret access to service account"
          exit 1
        fi

        # Clean up the temporary key file
        echo "üßπ Cleaning up temporary key file..."
        rm -f "{{.TEMP_KEY_FILE}}"

        echo "‚úÖ GCP service account key created and stored in Secret Manager"
        echo "Project ID: $GCP_PROJECT_ID"
        echo "Service Account: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        echo "Secret Name: {{.GCP_SECRET_NAME}}"
    summary: "Create GCP service account key and store it in GCP Secret Manager"

  configure-gcp-provider:
    desc: "Configure GCP provider with service account credentials"
    silent: true
    deps: [install-gcp-provider]
    requires:
      vars: [GCP_PROJECT_ID]
    vars:
      CROSSPLANE_SERVICE_ACCOUNT_EMAIL: "crossplane@{{.GCP_PROJECT_ID}}.iam.gserviceaccount.com"

    cmds:
      - |
        echo "üîê Configuring GCP provider credentials..."

        # Check if GCP_PROJECT_ID is set
        if [ -z "$GCP_PROJECT_ID" ]; then
          echo "‚ùå Error: GCP_PROJECT_ID environment variable is not set"
          echo "Please set it with: export GCP_PROJECT_ID=your-project-id"
          exit 1
        fi

        # Check if gcloud is installed and authenticated
        if ! command -v gcloud &> /dev/null; then
          echo "‚ùå Error: gcloud CLI is not installed"
          echo "Please install it from: https://cloud.google.com/sdk/docs/install"
          exit 1
        fi

        # Set the project
        echo "üîß Setting GCP project to $GCP_PROJECT_ID..."
        gcloud config set project $GCP_PROJECT_ID

        # Check if the GCP secret already exists in Secret Manager
        echo "üîç Checking if GCP secret exists in Secret Manager..."
        if gcloud secrets describe {{.GCP_SECRET_NAME}} --project=$GCP_PROJECT_ID &> /dev/null; then
          echo "‚úÖ GCP secret {{.GCP_SECRET_NAME}} already exists in Secret Manager"
          echo "‚ÑπÔ∏è  Using existing secret: {{.GCP_SECRET_NAME}}"
        else
          echo "‚ùå Error: GCP secret not found in Secret Manager, please create it using `task create-gcp-key`"
          exit 1
        fi

        # Download the secret from GCP Secret Manager and create Kubernetes secret
        echo "üîë Downloading secret from GCP Secret Manager..."
        TEMP_KEY_FILE="/tmp/crossplane-gcp-key-from-secret.json"

        # Get the latest version of the secret
        if ! gcloud secrets versions access latest --secret="{{.GCP_SECRET_NAME}}" --project=$GCP_PROJECT_ID > "$TEMP_KEY_FILE"; then
          echo "‚ùå Error: Failed to download secret from GCP Secret Manager"
          exit 1
        fi

        # Verify key file was downloaded
        if [ ! -f "$TEMP_KEY_FILE" ] || [ ! -s "$TEMP_KEY_FILE" ]; then
          echo "‚ùå Error: Secret file was not downloaded or is empty"
          exit 1
        fi

        # Create Kubernetes secret from the downloaded key
        echo "üîë Creating Kubernetes secret from GCP Secret Manager..."
        if ! kubectl create secret generic gcp-provider-creds \
          --from-file=credentials="$TEMP_KEY_FILE" \
          --namespace=crossplane-system \
          --dry-run=client -o yaml | kubectl apply -f -; then
          echo "‚ùå Error: Failed to create Kubernetes secret from GCP secret"
          exit 1
        fi

        # Clean up the temporary key file
        echo "üßπ Cleaning up temporary key file..."
        rm -f "$TEMP_KEY_FILE"

        # Create ProviderConfig for GCP
        echo "‚öôÔ∏è  Creating GCP ProviderConfig..."
        cat > /tmp/gcp-providerconfig.yaml << EOF
        apiVersion: gcp.upbound.io/v1beta1
        kind: ProviderConfig
        metadata:
          name: default
        spec:
          projectID: $GCP_PROJECT_ID
          credentials:
            source: Secret
            secretRef:
              namespace: crossplane-system
              name: gcp-provider-creds
              key: credentials
        EOF

        kubectl apply -f /tmp/gcp-providerconfig.yaml
        rm -f /tmp/gcp-providerconfig.yaml

        echo "‚úÖ GCP provider configured successfully"
        echo "Project ID: $GCP_PROJECT_ID"
        echo "Service Account: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        echo "Secret Name: {{.GCP_SECRET_NAME}}"
    summary: "Configure GCP provider with service account credentials from GCP Secret Manager"

  setup-gcp:
    desc: "Complete GCP setup (uninstall old provider + install new provider + configuration)"
    deps:
      [uninstall-gcp-provider, install-gcp-providers, configure-gcp-provider]
    summary: "Uninstall old GCP provider, install new provider from Upbound registry, and configure it"

  # Utility Tasks
  logs:
    desc: "Show Crossplane logs"
    silent: true
    cmds:
      - kubectl logs -n crossplane-system -l app=crossplane --tail=50

  port-forward:
    desc: "Port forward Crossplane API server (for debugging)"
    silent: true
    cmds:
      - kubectl port-forward -n crossplane-system svc/crossplane 8080:8080

  # Debug Tasks
  debug-provider-config:
    desc: "Debug GCP provider config status and events"
    silent: true
    cmds:
      - |
        echo "üîç Provider Config Status:"
        kubectl get providerconfig.gcp.m.upbound.io/default -o yaml
        echo ""
        echo "üîç Provider Status:"
        kubectl get provider.pkg.crossplane.io/upbound-provider-gcp-iam -o yaml
        echo ""
        echo "üîç Provider Events:"
        kubectl get events --field-selector involvedObject.name=upbound-provider-gcp-iam --sort-by='.lastTimestamp'
        echo ""
        echo "üîç Provider Config Events:"
        kubectl get events --field-selector involvedObject.name=default --sort-by='.lastTimestamp'
    summary: "Debug GCP provider config and provider status"

  # Help
  help:
    desc: "Show available Crossplane tasks"
    silent: true
    cmds:
      - task --list
