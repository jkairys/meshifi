version: "3"

vars:
  CROSSPLANE_SERVICE_ACCOUNT_EMAIL: "crossplane@{{.GCP_PROJECT_ID}}.iam.gserviceaccount.com"
  GCP_SECRET_NAME: "crossplane-gcp-key"

tasks:
  deps:
    desc: "Check required variables are set"
    requires:
      vars: [GCP_PROJECT_ID]
    summary: "Check required variables are set"
    cmds:
      - |
        echo "üîç Checking required variables are set..."
        if [ -z "$GCP_PROJECT_ID" ]; then
          echo "‚ùå Error: GCP_PROJECT_ID environment variable is not set"
          echo "Please set it with: export GCP_PROJECT_ID=your-project-id"
          exit 1
        fi

  # GCP Provider Setup
  uninstall-gcp-provider:
    desc: "Uninstall existing GCP provider from the cluster"
    silent: true
    deps: [deps]
    cmds:
      - |
        echo "üóëÔ∏è  Uninstalling existing GCP provider..."

        # Check if cluster exists and is accessible
        if ! kubectl cluster-info &> /dev/null; then
          echo "‚ÑπÔ∏è  No accessible Kubernetes cluster found. Skipping GCP provider uninstall."
          exit 0
        fi

        # Check if old provider-gcp is installed
        if kubectl get provider.pkg.crossplane.io/provider-gcp &> /dev/null; then
          echo "üîß Uninstalling existing provider-gcp..."
          kubectl delete provider.pkg.crossplane.io/provider-gcp --ignore-not-found=true
          
          # Wait for provider to be removed
          echo "‚è≥ Waiting for provider to be removed..."
          kubectl wait --for=delete provider.pkg.crossplane.io/provider-gcp --timeout=60s || true
          
          echo "‚úÖ Existing provider-gcp uninstalled"
        fi

        # Check if new upbound-provider-gcp-iam is installed
        if kubectl get provider.pkg.crossplane.io/upbound-provider-gcp-iam &> /dev/null; then
          echo "üîß Uninstalling existing upbound-provider-gcp-iam..."
          kubectl delete provider.pkg.crossplane.io/upbound-provider-gcp-iam --ignore-not-found=true
          
          # Wait for provider to be removed
          echo "‚è≥ Waiting for provider to be removed..."
          kubectl wait --for=delete provider.pkg.crossplane.io/upbound-provider-gcp-iam --timeout=60s || true
          
          echo "‚úÖ Existing upbound-provider-gcp-iam uninstalled"
        fi

        # Also check for the family provider
        if kubectl get provider.pkg.crossplane.io/upbound-provider-family-gcp &> /dev/null; then
          echo "üîß Uninstalling existing upbound-provider-family-gcp..."
          kubectl delete provider.pkg.crossplane.io/upbound-provider-family-gcp --ignore-not-found=true
          
          # Wait for provider to be removed
          echo "‚è≥ Waiting for provider to be removed..."
          kubectl wait --for=delete provider.pkg.crossplane.io/upbound-provider-family-gcp --timeout=60s || true
          
          echo "‚úÖ Existing upbound-provider-family-gcp uninstalled"
        fi

        # Clean up any existing GCP ProviderConfigs that might cause conflicts
        echo "üßπ Cleaning up existing GCP ProviderConfigs..."
        kubectl delete providerconfig.gcp.m.upbound.io --all --ignore-not-found=true || true
        kubectl delete providerconfig.gcp.upbound.io --all --ignore-not-found=true || true
        kubectl delete providerconfig.gcp.crossplane.io --all --ignore-not-found=true || true

        # Check if any GCP provider is installed
        if ! kubectl get provider.pkg.crossplane.io/provider-gcp &> /dev/null && ! kubectl get provider.pkg.crossplane.io/upbound-provider-gcp-iam &> /dev/null && ! kubectl get provider.pkg.crossplane.io/upbound-provider-family-gcp &> /dev/null; then
          echo "‚ÑπÔ∏è  No existing GCP provider found to uninstall"
        fi
    summary: "Uninstall existing GCP provider from the cluster"

  install-gcp-providers:
    desc: "Install upjet GCP provider for Crossplane from Upbound registry"
    silent: true
    deps: [deps, uninstall-gcp-provider]
    cmds:
      - |
        echo "üîß Installing upjet GCP provider from Upbound registry..."
        kubectl apply -f providers

        echo "‚è≥ Waiting for GCP IAM provider to be ready..."
        kubectl wait --for=condition=Healthy --timeout=300s provider.pkg.crossplane.io/upbound-provider-gcp-iam

        echo "‚è≥ Waiting for provider config resource CRD to be available..."
        kubectl wait --for=condition=Established --timeout=300s crd/providerconfigs.gcp.m.upbound.io

        echo "üìã Creating ProviderConfig with project ID: $GCP_PROJECT_ID..."
        envsubst < provider-config.yaml | kubectl apply -f -

        echo "üîç Checking provider config status..."
        kubectl get providerconfig.gcp.m.upbound.io/default -o yaml

        echo "üîç Checking provider events..."
        kubectl get events --field-selector involvedObject.name=upbound-provider-gcp-iam --sort-by='.lastTimestamp'

        echo "‚è≥ Checking if GCP provider config is ready..."
        # Note: upjet providers may not set Healthy condition on ProviderConfig
        # Just verify the ProviderConfig exists and provider is running
        kubectl get providerconfig.gcp.m.upbound.io/default
        kubectl get pods -n crossplane-system | grep gcp

        echo "‚úÖ upjet GCP provider is ready"
    summary: "Install upjet GCP provider for Crossplane from Upbound registry"

  create-gcp-key:
    desc: "Create GCP service account key and store it in GCP Secret Manager"
    silent: true
    requires:
      vars: [GCP_PROJECT_ID]
    vars:
      CROSSPLANE_SERVICE_ACCOUNT_NAME: crossplane
      CROSSPLANE_SERVICE_ACCOUNT_EMAIL: "{{.CROSSPLANE_SERVICE_ACCOUNT_NAME}}@{{.GCP_PROJECT_ID}}.iam.gserviceaccount.com"
      TEMP_KEY_FILE: "/tmp/crossplane-gcp-key.json"

    cmds:
      - |
        echo "üîë Creating GCP service account key and storing in Secret Manager..."

        # Check if GCP_PROJECT_ID is set
        if [ -z "$GCP_PROJECT_ID" ]; then
          echo "‚ùå Error: GCP_PROJECT_ID environment variable is not set"
          echo "Please set it with: export GCP_PROJECT_ID=your-project-id"
          exit 1
        fi

        # Check if gcloud is installed and authenticated
        if ! command -v gcloud &> /dev/null; then
          echo "‚ùå Error: gcloud CLI is not installed"
          echo "Please install it from: https://cloud.google.com/sdk/docs/install"
          exit 1
        fi

        # Check if user is authenticated
        if ! gcloud auth list --filter=status:ACTIVE --format="value(account)" | grep -q .; then
          echo "‚ùå Error: No active gcloud authentication found"
          echo "Please run: gcloud auth login"
          exit 1
        fi

        # Set the project
        echo "üîß Setting GCP project to $GCP_PROJECT_ID..."
        gcloud config set project $GCP_PROJECT_ID

        # Enable Secret Manager API if not already enabled
        echo "üîß Ensuring Secret Manager API is enabled..."
        gcloud services enable secretmanager.googleapis.com

        # Debug: Show variables
        echo "üîç Debug - GCP_PROJECT_ID: $GCP_PROJECT_ID"
        echo "üîç Debug - CROSSPLANE_SERVICE_ACCOUNT_NAME: {{.CROSSPLANE_SERVICE_ACCOUNT_NAME}}"
        echo "üîç Debug - CROSSPLANE_SERVICE_ACCOUNT_EMAIL: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        echo "üîç Debug - GCP_SECRET_NAME: {{.GCP_SECRET_NAME}}"

        # Validate that the service account email was constructed properly
        if [ -z "{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" ]; then
          echo "‚ùå Error: Service account email is empty. Check GCP_PROJECT_ID variable."
          exit 1
        fi

        # Check if service account exists by listing and filtering
        echo "üîç Checking if service account exists: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        if gcloud iam service-accounts list --filter="email:{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" --format="value(email)" | grep -q "^{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}$"; then
          echo "‚úÖ Service account already exists: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        else
          echo "üîß Creating service account: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
          gcloud iam service-accounts create {{.CROSSPLANE_SERVICE_ACCOUNT_NAME}} \
            --display-name="Crossplane" \
            --description="Service account for Crossplane GCP provider"
          
          # Grant Project IAM Admin role to the newly created service account
          echo "üîê Granting Project IAM Admin role to newly created service account..."
          gcloud projects add-iam-policy-binding $GCP_PROJECT_ID \
            --member="serviceAccount:{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" \
            --role="roles/resourcemanager.projectIamAdmin"
        fi

        # Assign required roles to service account for Crossplane operations
        echo "üîê Assigning required roles to service account..."
        ROLES=(
          "roles/resourcemanager.projectIamAdmin"
          "roles/bigquery.admin"
          "roles/iam.serviceAccountAdmin"
          "roles/iam.serviceAccountKeyAdmin"
        )

        for role in "${ROLES[@]}"; do
          echo "  - Assigning role: $role"
          if ! gcloud projects add-iam-policy-binding $GCP_PROJECT_ID \
            --member="serviceAccount:{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" \
            --role="$role" \
            --quiet; then
            echo "‚ùå Error: Failed to assign role $role to service account"
            echo "This may be due to insufficient permissions or the role already being assigned"
            echo "Continuing with remaining roles..."
          else
            echo "    ‚úÖ Role assigned successfully"
          fi
        done

        # Enable required GCP APIs
        echo "üîß Enabling required GCP APIs..."
        gcloud services enable cloudresourcemanager.googleapis.com --project={{.GCP_PROJECT_ID}}
        gcloud services enable iam.googleapis.com --project={{.GCP_PROJECT_ID}}

        # Check if service account already has keys in GCP
        echo "üîç Checking if service account has existing keys in GCP..."
        EXISTING_KEYS=$(gcloud iam service-accounts keys list \
          --iam-account={{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}} \
          --format="value(name)" 2>/dev/null | wc -l)

        if [ "$EXISTING_KEYS" -gt 0 ]; then
          echo "‚úÖ Found $EXISTING_KEYS existing key(s) in GCP"
          echo "‚ÑπÔ∏è  Note: GCP doesn't allow downloading existing keys for security reasons"
          echo "üîë Creating a new service account key (existing keys will remain valid)..."
        else
          echo "üîë No existing keys found in GCP, creating new service account key..."
        fi

        # Create a new service account key
        if ! gcloud iam service-accounts keys create {{.TEMP_KEY_FILE}} \
          --iam-account={{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}; then
          echo "‚ùå Error: Failed to create service account key"
          exit 1
        fi

        # Verify key file was created
        if [ ! -f "{{.TEMP_KEY_FILE}}" ]; then
          echo "‚ùå Error: Service account key file was not created"
          exit 1
        fi

        # Check if secret already exists in GCP Secret Manager
        echo "üîç Checking if secret already exists in GCP Secret Manager..."
        if gcloud secrets describe {{.GCP_SECRET_NAME}} --project=$GCP_PROJECT_ID &> /dev/null; then
          echo "‚úÖ Secret {{.GCP_SECRET_NAME}} already exists in GCP Secret Manager"
          echo "üîÑ Updating existing secret with new key..."
          
          # Update the existing secret
          if ! gcloud secrets versions add {{.GCP_SECRET_NAME}} \
            --data-file="{{.TEMP_KEY_FILE}}" \
            --project=$GCP_PROJECT_ID; then
            echo "‚ùå Error: Failed to update existing secret"
            exit 1
          fi
        else
          echo "üîë Creating new secret in GCP Secret Manager..."
          
          # Create the secret
          if ! gcloud secrets create {{.GCP_SECRET_NAME}} \
            --replication-policy="automatic" \
            --project=$GCP_PROJECT_ID; then
            echo "‚ùå Error: Failed to create secret"
            exit 1
          fi
          
          # Add the first version
          if ! gcloud secrets versions add {{.GCP_SECRET_NAME}} \
            --data-file="{{.TEMP_KEY_FILE}}" \
            --project=$GCP_PROJECT_ID; then
            echo "‚ùå Error: Failed to add secret version"
            exit 1
          fi
        fi

        # Grant the service account access to read the secret
        echo "üîê Granting service account access to read the secret..."
        if ! gcloud secrets add-iam-policy-binding {{.GCP_SECRET_NAME}} \
          --member="serviceAccount:{{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}" \
          --role="roles/secretmanager.secretAccessor" \
          --project=$GCP_PROJECT_ID; then
          echo "‚ùå Error: Failed to grant secret access to service account"
          exit 1
        fi

        # Clean up the temporary key file
        echo "üßπ Cleaning up temporary key file..."
        rm -f "{{.TEMP_KEY_FILE}}"

        echo "‚úÖ GCP service account key created and stored in Secret Manager"
        echo "Project ID: $GCP_PROJECT_ID"
        echo "Service Account: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        echo "Secret Name: {{.GCP_SECRET_NAME}}"
    summary: "Create GCP service account key and store it in GCP Secret Manager"

  configure-gcp-provider:
    desc: "Configure GCP provider with service account credentials"
    silent: true
    deps: [install-gcp-providers]
    requires:
      vars: [GCP_PROJECT_ID]

    cmds:
      - |
        echo "üîê Configuring GCP provider credentials..."

        # Check if GCP_PROJECT_ID is set
        if [ -z "$GCP_PROJECT_ID" ]; then
          echo "‚ùå Error: GCP_PROJECT_ID environment variable is not set"
          echo "Please set it with: export GCP_PROJECT_ID=your-project-id"
          exit 1
        fi

        # Check if gcloud is installed and authenticated
        if ! command -v gcloud &> /dev/null; then
          echo "‚ùå Error: gcloud CLI is not installed"
          echo "Please install it from: https://cloud.google.com/sdk/docs/install"
          exit 1
        fi

        # Set the project
        echo "üîß Setting GCP project to $GCP_PROJECT_ID..."
        gcloud config set project $GCP_PROJECT_ID

        # Check if the GCP secret already exists in Secret Manager
        echo "üîç Checking if GCP secret exists in Secret Manager..."
        if gcloud secrets describe {{.GCP_SECRET_NAME}} --project=$GCP_PROJECT_ID &> /dev/null; then
          echo "‚úÖ GCP secret {{.GCP_SECRET_NAME}} already exists in Secret Manager"
          echo "‚ÑπÔ∏è  Using existing secret: {{.GCP_SECRET_NAME}}"
        else
          echo "‚ùå Error: GCP secret not found in Secret Manager, please create it using `task create-gcp-key`"
          exit 1
        fi

        # Download the secret from GCP Secret Manager and create Kubernetes secret
        echo "üîë Downloading secret from GCP Secret Manager..."
        TEMP_KEY_FILE="/tmp/crossplane-gcp-key-from-secret.json"

        # Get the latest version of the secret
        if ! gcloud secrets versions access latest --secret="{{.GCP_SECRET_NAME}}" --project=$GCP_PROJECT_ID > "$TEMP_KEY_FILE"; then
          echo "‚ùå Error: Failed to download secret from GCP Secret Manager"
          exit 1
        fi

        # Verify key file was downloaded
        if [ ! -f "$TEMP_KEY_FILE" ] || [ ! -s "$TEMP_KEY_FILE" ]; then
          echo "‚ùå Error: Secret file was not downloaded or is empty"
          exit 1
        fi

        # Create Kubernetes secret from the downloaded key in crossplane-system namespace
        echo "üîë Creating Kubernetes secret in crossplane-system namespace..."
        if ! kubectl create secret generic gcp-provider-creds \
          --from-file=credentials="$TEMP_KEY_FILE" \
          --namespace=crossplane-system \
          --dry-run=client -o yaml | kubectl apply -f -; then
          echo "‚ùå Error: Failed to create Kubernetes secret from GCP secret"
          exit 1
        fi

        # Also create the secret in default namespace for resources created there
        echo "üîë Creating Kubernetes secret in default namespace..."
        if ! kubectl create secret generic gcp-provider-creds \
          --from-file=credentials="$TEMP_KEY_FILE" \
          --namespace=default \
          --dry-run=client -o yaml | kubectl apply -f -; then
          echo "‚ùå Error: Failed to create Kubernetes secret in default namespace"
          exit 1
        fi

        # Clean up the temporary key file
        echo "üßπ Cleaning up temporary key file..."
        rm -f "$TEMP_KEY_FILE"

        # Note: ProviderConfig is created by install-gcp-providers task from provider-config.yaml
        # The gcp.m.upbound.io/v1beta1 API version is used (namespaced)
        # No need to create a separate cluster-scoped ProviderConfig here

        echo "‚úÖ GCP provider configured successfully"
        echo "Project ID: $GCP_PROJECT_ID"
        echo "Service Account: {{.CROSSPLANE_SERVICE_ACCOUNT_EMAIL}}"
        echo "Secret Name: {{.GCP_SECRET_NAME}}"
    summary: "Configure GCP provider with service account credentials from GCP Secret Manager"

  setup:
    desc: "Complete GCP setup (uninstall old provider + install new provider + configuration)"
    summary: "Uninstall old GCP provider, install new provider from Upbound registry, and configure it"
    cmds:
      - task: uninstall-gcp-provider
      - task: install-gcp-providers
      - task: configure-gcp-provider
  # Debug Tasks
  debug-provider-config:
    desc: "Debug GCP provider config status and events"
    silent: true
    cmds:
      - |
        echo "üîç Provider Config Status:"
        kubectl get providerconfig.gcp.m.upbound.io/default -o yaml
        echo ""
        echo "üîç Provider Status:"
        kubectl get provider.pkg.crossplane.io/upbound-provider-gcp-iam -o yaml
        echo ""
        echo "üîç Provider Events:"
        kubectl get events --field-selector involvedObject.name=upbound-provider-gcp-iam --sort-by='.lastTimestamp'
        echo ""
        echo "üîç Provider Config Events:"
        kubectl get events --field-selector involvedObject.name=default --sort-by='.lastTimestamp'
    summary: "Debug GCP provider config and provider status"
